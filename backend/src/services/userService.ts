import pool from '../config/database';
import { User, UserRegistrationData, UserResponse, UserUpdateData } from '../types/user';
import { hashPassword, comparePassword } from '../utils/password';
import { generateAccessToken, generateRefreshToken, getTokenExpiration } from '../utils/jwt';
import { AppError } from '../middleware/errorHandler';

/**
 * Create a new user
 */
export const createUser = async (userData: UserRegistrationData): Promise<UserResponse> => {
  const client = await pool.connect();
  
  try {
    // Check if user already exists
    const existingUser = await client.query(
      'SELECT id FROM users WHERE email = $1',
      [userData.email]
    );

    if (existingUser.rows.length > 0) {
      throw new AppError('User with this email already exists', 409);
    }

    // Hash password
    const hashedPassword = await hashPassword(userData.password);

    // Determine currency based on country if not provided
    const getCurrencyFromCountry = (countryCode?: string): string => {
      if (!countryCode) return 'INR'; // Default
      const country = countryCode.toUpperCase();
      // Map common countries to currencies
      if (['US', 'CA', 'AU', 'NZ'].includes(country)) return 'USD';
      if (['GB', 'UK'].includes(country)) return 'GBP';
      if (['EU', 'DE', 'FR', 'IT', 'ES', 'NL', 'BE', 'AT', 'PT', 'IE', 'FI', 'GR'].includes(country)) return 'EUR';
      if (['JP'].includes(country)) return 'JPY';
      if (['CN'].includes(country)) return 'CNY';
      if (['IN'].includes(country)) return 'INR';
      return 'INR'; // Default to INR
    };

    const currency = userData.currency || getCurrencyFromCountry(userData.country);

    // Insert user (id is auto-generated by SERIAL)
    const result = await client.query(
      `INSERT INTO users (
        "fullName", email, password, country, "mobileNumber", 
        "planId", logo, gstin, pan, currency, "emailVerified", "isActive", 
        "createdAt", "updatedAt"
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
      RETURNING 
        id, "fullName", email, country, "mobileNumber", "planId", logo, 
        gstin, pan, currency, "emailVerified", "isActive", "isTwoFactorEnabled", 
        "lastLogin", "createdAt", "updatedAt"`,
      [
        userData.fullName,
        userData.email,
        hashedPassword,
        userData.country || null,
        userData.mobileNumber || null,
        userData.planId || null,
        userData.logo || null,
        userData.gstin || null,
        userData.pan || null,
        currency,
        false, // emailVerified
        true, // isActive
      ]
    );

    const user = result.rows[0];
    return mapUserToResponse(user);
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    console.error('Error creating user:', error);
    throw new AppError('Failed to create user', 500);
  } finally {
    client.release();
  }
};

/**
 * Authenticate user and return tokens
 */
export const authenticateUser = async (
  email: string,
  password: string
): Promise<{
  user: UserResponse;
  accessToken: string;
  refreshToken: string;
  jwtIssuedAt: Date;
  jwtExpiresAt: Date;
}> => {
  const client = await pool.connect();

  try {
    // Find user by email
    const result = await client.query(
      'SELECT * FROM users WHERE email = $1',
      [email]
    );

    if (result.rows.length === 0) {
      throw new AppError('Invalid email or password', 401);
    }

    const user: User = result.rows[0];

    // Check if user is active
    if (!user.isActive) {
      throw new AppError('Account is deactivated', 403);
    }

    // Verify password
    const isPasswordValid = await comparePassword(password, user.password);
    if (!isPasswordValid) {
      // Increment login attempts
      await client.query(
        'UPDATE users SET "loginAttempts" = "loginAttempts" + 1 WHERE id = $1',
        [user.id]
      );
      throw new AppError('Invalid email or password', 401);
    }

    // Reset login attempts on successful login
    const jwtIssuedAt = new Date();
    const jwtExpiresAt = getTokenExpiration();

    // Generate tokens
    const accessToken = generateAccessToken({ userId: user.id, email: user.email });
    const refreshToken = generateRefreshToken({ userId: user.id, email: user.email });

    // Update user with login info
    await client.query(
      `UPDATE users SET 
        "lastLogin" = CURRENT_TIMESTAMP,
        "loginAttempts" = 0,
        "refreshToken" = $1,
        "jwtIssuedAt" = $2,
        "jwtExpiresAt" = $3
      WHERE id = $4`,
      [refreshToken, jwtIssuedAt, jwtExpiresAt, user.id]
    );

    const userResponse = mapUserToResponse(user);
    userResponse.lastLogin = jwtIssuedAt;

    return {
      user: userResponse,
      accessToken,
      refreshToken,
      jwtIssuedAt,
      jwtExpiresAt,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    console.error('Error authenticating user:', error);
    throw new AppError('Authentication failed', 500);
  } finally {
    client.release();
  }
};

/**
 * Get user by ID
 */
export const getUserById = async (userId: number): Promise<UserResponse> => {
  const client = await pool.connect();

  try {
    const result = await client.query(
      `SELECT 
        id, "fullName", email, country, "mobileNumber", "planId", logo, 
        gstin, pan, currency, "emailVerified", "isActive", "isTwoFactorEnabled", 
        "lastLogin", "createdAt", "updatedAt"
      FROM users WHERE id = $1`,
      [userId]
    );

    if (result.rows.length === 0) {
      throw new AppError('User not found', 404);
    }

    return mapUserToResponse(result.rows[0]);
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    throw new AppError('Failed to retrieve user', 500);
  } finally {
    client.release();
  }
};

/**
 * Update user profile
 */
export const updateUser = async (
  userId: number,
  updateData: UserUpdateData
): Promise<UserResponse> => {
  const client = await pool.connect();

  try {
    // Check if user exists
    const existingUser = await client.query(
      'SELECT id FROM users WHERE id = $1',
      [userId]
    );

    if (existingUser.rows.length === 0) {
      throw new AppError('User not found', 404);
    }

    // If email is being updated, check for duplicates
    if (updateData.email) {
      const emailCheck = await client.query(
        'SELECT id FROM users WHERE email = $1 AND id != $2',
        [updateData.email, userId]
      );

      if (emailCheck.rows.length > 0) {
        throw new AppError('Email already in use', 409);
      }
    }

    // Build dynamic update query
    const updateFields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    if (updateData.fullName !== undefined) {
      updateFields.push(`"fullName" = $${paramIndex}`);
      values.push(updateData.fullName);
      paramIndex++;
    }
    if (updateData.email !== undefined) {
      updateFields.push(`email = $${paramIndex}`);
      values.push(updateData.email);
      paramIndex++;
    }
    if (updateData.country !== undefined) {
      updateFields.push(`country = $${paramIndex}`);
      values.push(updateData.country || null);
      paramIndex++;
    }
    if (updateData.mobileNumber !== undefined) {
      updateFields.push(`"mobileNumber" = $${paramIndex}`);
      values.push(updateData.mobileNumber || null);
      paramIndex++;
    }
    if (updateData.gstin !== undefined) {
      updateFields.push(`gstin = $${paramIndex}`);
      values.push(updateData.gstin || null);
      paramIndex++;
    }
    if (updateData.pan !== undefined) {
      updateFields.push(`pan = $${paramIndex}`);
      values.push(updateData.pan || null);
      paramIndex++;
    }
    if (updateData.currency !== undefined) {
      updateFields.push(`currency = $${paramIndex}`);
      values.push(updateData.currency);
      paramIndex++;
    }
    if (updateData.logo !== undefined) {
      updateFields.push(`logo = $${paramIndex}`);
      values.push(updateData.logo || null);
      paramIndex++;
    }

    if (updateFields.length === 0) {
      // No fields to update, just return current user
      return await getUserById(userId);
    }

    // Add userId to values for WHERE clause
    values.push(userId);

    // Execute update
    const result = await client.query(
      `UPDATE users 
       SET ${updateFields.join(', ')}, "updatedAt" = CURRENT_TIMESTAMP
       WHERE id = $${paramIndex}
       RETURNING 
         id, "fullName", email, country, "mobileNumber", "planId", logo, 
         gstin, pan, currency, "emailVerified", "isActive", "isTwoFactorEnabled", 
         "lastLogin", "createdAt", "updatedAt"`,
      values
    );

    return mapUserToResponse(result.rows[0]);
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    console.error('Error updating user:', error);
    throw new AppError('Failed to update user', 500);
  } finally {
    client.release();
  }
};

/**
 * Map database user to response DTO (excluding sensitive data)
 */
const mapUserToResponse = (dbUser: any): UserResponse => {
  return {
    id: dbUser.id,
    fullName: dbUser.fullName,
    email: dbUser.email,
    country: dbUser.country,
    mobileNumber: dbUser.mobileNumber,
    planId: dbUser.planId,
    logo: dbUser.logo,
    gstin: dbUser.gstin,
    pan: dbUser.pan,
    currency: dbUser.currency || 'INR',
    emailVerified: dbUser.emailVerified,
    isActive: dbUser.isActive,
    isTwoFactorEnabled: dbUser.isTwoFactorEnabled,
    lastLogin: dbUser.lastLogin ? new Date(dbUser.lastLogin) : undefined,
    createdAt: new Date(dbUser.createdAt),
    updatedAt: new Date(dbUser.updatedAt),
  };
};

