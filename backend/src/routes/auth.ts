import express from 'express';
import multer from 'multer';
import { createUser, authenticateUser } from '../services/userService';
import { validateRegister, validateLogin } from '../middleware/validator';
import { AppError } from '../middleware/errorHandler';
import { authRateLimiter, strictRateLimiter } from '../middleware/security';
import { createSession, logoutAllSessions } from '../services/sessionService';
import { authenticateToken, AuthRequest } from '../middleware/auth';
import BlobStorageService, { FileType } from '../services/blobStorageService';
import pool from '../config/database';

const router = express.Router();

// Allowed image MIME types
const ALLOWED_IMAGE_TYPES = [
  'image/jpeg',
  'image/jpg',
  'image/png',
  'image/gif',
  'image/webp',
];

// Allowed file extensions
const ALLOWED_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];

const fileFilter: multer.Options['fileFilter'] = (_req, file, cb) => {
  // Check MIME type
  if (!ALLOWED_IMAGE_TYPES.includes(file.mimetype)) {
    cb(new AppError('Only image files (JPEG, PNG, GIF, WebP) are allowed for logo uploads', 400));
    return;
  }

  // Check file extension (using string methods instead of path)
  const fileName = file.originalname.toLowerCase();
  const hasValidExtension = ALLOWED_EXTENSIONS.some(ext => fileName.endsWith(ext));
  if (!hasValidExtension) {
    cb(new AppError('Invalid file extension. Only image files are allowed', 400));
    return;
  }

  // Additional security: Check for potentially dangerous filenames
  const dangerousPatterns = /\.\.|\.exe|\.sh|\.bat|\.cmd|\.php|\.js$/i;
  if (dangerousPatterns.test(file.originalname)) {
    cb(new AppError('Invalid filename. Potentially dangerous file detected', 400));
    return;
  }

  cb(null, true);
};

// Use memory storage for Azure Blob uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 2 * 1024 * 1024, // 2MB max
    files: 1, // Only one file
    fieldSize: 10 * 1024 * 1024, // 10MB max field size
  },
  fileFilter,
});

/**
 * @route   POST /api/auth/register
 * @desc    Register a new user
 * @access  Public
 */
// Logo is optional - can be uploaded during registration or later
// upload.single() handles optional files - req.file will be undefined if no file is provided
router.post('/register', strictRateLimiter, upload.single('logo'), validateRegister, async (req, res, next) => {
  try {
    // Remove id from body if provided (it's auto-generated)
    const { id, ...userData } = req.body;

    // Note: The sample data provided should not be inserted as-is.
    // This endpoint handles registration with proper validation and password hashing.
    // The id field is auto-generated by the database.

    const user = await createUser(userData);

    // Upload logo to Azure Blob Storage (required - no local fallback)
    if (req.file && user.id) {
      // Generate unique filename with timestamp
      const fileExtension = req.file.originalname.split('.').pop() || 
        (req.file.mimetype === 'image/jpeg' ? 'jpg' :
         req.file.mimetype === 'image/png' ? 'png' :
         req.file.mimetype === 'image/gif' ? 'gif' :
         req.file.mimetype === 'image/webp' ? 'webp' : 'jpg');
      const baseName = req.file.originalname.replace(/\.[^/.]+$/, '') || 'logo';
      const uniqueFileName = `${baseName}_${Date.now()}.${fileExtension}`;
      
      const blobPath = await BlobStorageService.uploadFile(
        req.file.buffer,
        uniqueFileName,
        FileType.LOGO,
        user.id,
        req.file.mimetype
      );
      // Update user with blob path
      const client = await pool.connect();
      try {
        await client.query('UPDATE users SET logo = $1 WHERE id = $2', [blobPath, user.id]);
        user.logo = blobPath;
      } finally {
        client.release();
      }
    }

    res.status(201).json({
      success: true,
      message: 'User registered successfully',
      user,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * @route   POST /api/auth/login
 * @desc    Authenticate user and return tokens
 * @access  Public
 */
router.post('/login', authRateLimiter, validateLogin, async (req, res, next) => {
  try {
    const { email, password } = req.body;

    const authResult = await authenticateUser(email, password);

    // Track login session
    try {
      const ipAddress = req.ip || req.socket.remoteAddress || undefined;
      const userAgent = req.get('user-agent') || undefined;
      await createSession({
        userId: authResult.user.id,
        ipAddress,
        userAgent,
      });
    } catch (sessionError) {
      // Log but don't fail login if session tracking fails
      console.error('Failed to track login session:', sessionError);
    }

    res.status(200).json({
      success: true,
      message: 'Login successful',
      user: authResult.user,
      accessToken: authResult.accessToken,
      refreshToken: authResult.refreshToken,
      jwtIssuedAt: authResult.jwtIssuedAt,
      jwtExpiresAt: authResult.jwtExpiresAt,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * @route   POST /api/auth/logout
 * @desc    Logout user and update session
 * @access  Private
 */
router.post('/logout', authenticateToken, async (req: AuthRequest, res, next) => {
  try {
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'Unauthorized',
      });
    }

    // Logout all active sessions for the user
    await logoutAllSessions(req.user.userId);

    res.status(200).json({
      success: true,
      message: 'Logout successful',
    });
  } catch (error) {
    next(error);
  }
});

export default router;

